package com.peter.rogue.entities;

import java.util.ArrayList;

import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.math.collision.Ray;
import com.peter.rogue.Global;
import com.peter.rogue.inventory.Chest;
import com.peter.rogue.inventory.Inventory;
import com.peter.rogue.inventory.Item;
import com.peter.rogue.map.Tile;

public class Player extends Animate implements InputProcessor {
	
	private float zoom = 1f;
	private Texture picture;
	private String info;
	private String menu = "null";
	private boolean menuActive = false;
	private Inventory inventory = new Inventory();
	private ArrayList<Ray> rays = new ArrayList<Ray>();
	private Entity menuObject;
	private int wallet;
	private int viewDistance;
    private boolean newMap = false;
	private boolean hostile;
	
	public Player(String filename){
		super(filename, "Player");
		messageFlag = false;
		name = "Adelaide";
		picture = new Texture(Gdx.files.internal("img/adelaide.png"));
		info = new String();
		viewDistance = 224;
		hostile = false;
		setWallet(0);
		stats.setDexterity(5);
		stats.setMaxExperience(100);
		stats.setExperience(0);
		stats.setLevel(1);
		stats.setStrength(5);
		stats.setHitpoints(20);
		stats.setMaxHitpoints(20);
		stats.setLevelPending(false);
		canDraw = true;
		
		
		for(int i=0; i<90; i++){
			rays.add(new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0)));
		}
	}

	public void draw(SpriteBatch spriteBatch){
		super.draw(spriteBatch);
		update(Gdx.graphics.getDeltaTime());
	}
	
	public Inventory getInventory(){
		return inventory;
	}
	
	public Texture getPicture(){
		return picture;
	}
	
	public void update(float delta){
		super.update(delta);
		findPath(new Node(22*32, 7*32), new Node(getX(), getY()));
		open.clear();
		closed.clear();
		if(delay >= .15){
			if(Gdx.input.isKeyPressed(Keys.A)){
				setX(getX() - 32);
				delay = 0;
			}
			if(Gdx.input.isKeyPressed(Keys.D)){
				setX(getX() + 32);
				delay = 0;
			}
			if(Gdx.input.isKeyPressed(Keys.S)){
				setY(getY() - 32);
				delay = 0;
			}
			if(Gdx.input.isKeyPressed(Keys.W)){
				setY(getY() + 32);
				delay = 0;
			}
			if(delay == 0f)
				menuActive = false;
			checkCollision();
		}
		
	}
	
	public void checkCollision(){

		if(map.getTile(getX(), getY()).isBlocked()){
			setX(oldX);
			setY(oldY);
		}
		else if(map.getTile(getX(), getY()).hasStairs() && !map.getTile(oldX, oldY).hasStairs()){
			if(map.getTile(getX(), getY()).direction()){
				newMap = true;
				map.load(1, getX(), getY());
			}
			else{
				newMap = true;
				map.load(-1, getX(), getY());
			}
		}
		if(!(map.getMark(getX(), getY()).equals("") || map.getMark(getX(), getY()).equals(ID))){
			if(map.get(getX(), getY()).getType().equals("Item")){
				inventory.add((Item)map.get(getX(), getY()));
				map.remove(map.get(getX(), getY()).getID());
			}
			
			else if(map.get(getX(), getY()).getType().equals("Chest")){
				setMenu("Chest");
				setMenuObject((Chest)map.get(getX(), getY()));
				bump();
			}
			
			else
				if(isHostile())
					attack((Animate) map.get(getX(), getY()));
				else{
					if(map.get(getX(), getY()) instanceof Shopkeep){
						setMenu("Barter");
						setMenuObject((Shopkeep)map.get(getX(), getY()));
					}
					bump((Animate) map.get(getX(), getY()));
				}
		}

		map.setMark("", oldX, oldY);
		map.setMark(ID, getX(), getY());
		oldX = getX();
		oldY = getY();
	}
	
    
    public void light(){
		//Global.mapShapes.begin(ShapeType.Line);
		//Global.mapShapes.setColor(Color.YELLOW);
		
		for(int i=0; i<rays.size(); i++){
			rays.get(i).set(new Vector3(getX()+getWidth()/2, getY()+getHeight()/2, 0), 
					        new Vector3((float)(getViewDistance()*Math.cos((2*Math.PI*i)/rays.size()) + getX()+getWidth()/2), 
					        		    (float)(getViewDistance()*Math.sin((2*Math.PI*i)/rays.size()) + getY()+getHeight()/2), 0f));
    		map.getSpriteBatch().begin();
			rays.get(i).direction.set(intersect(rays.get(i)));
    		map.getSpriteBatch().end();
    		
			//Global.mapShapes.line(rays.get(i).origin, rays.get(i).direction);
		}
		
		//Global.mapShapes.end();
    }
    
    public Vector3 intersect(Ray ray){
    	float x, y;
    	for(int i=1; i<=getViewDistance()/32; i++){
    		x = ray.origin.x + (((ray.direction.x - ray.origin.x)*i)/(getViewDistance()/32));
    		y = ray.origin.y + (((ray.direction.y - ray.origin.y)*i)/(getViewDistance()/32));
    		Tile tile = map.getTile(x, y);
    		map.setVisible(x, y, "visited");
	    	if(tile.isBlocked()){
	    		return new Vector3(ray.origin.x + (((ray.direction.x - ray.origin.x)*i)/(getViewDistance()/32)), 
	    				           ray.origin.y + (((ray.direction.y - ray.origin.y)*i)/(getViewDistance()/32)), 0);
	    	}
	    	// Render entities when in sight
	    	else if(!(map.getMark(x, y).equals(ID) || map.getMark(x, y).equals(""))){
		    	map.get(x, y).canDraw = true;
	    	}
    	}
    	return ray.direction;
    }
	
	
	@Override
	public boolean keyDown(int keycode) {
		switch(keycode){
		case Keys.G:
			setMenu("Inventory");
			break;
		case Keys.F:
			hostile = !hostile;
			break;
		case Keys.TAB:
			Global.camera.zoom += .4;
			break;
		case Keys.ESCAPE:
			System.exit(0);
		}
		return false;
	}


	@Override
	public boolean scrolled(int amount) {
		zoom += (.1f / amount);
		return true;
	}

	// Mouse scroll zoom (may break)
	public float getZoom() {
		return zoom;
	}
	
	public void setInformation(String info){
		this.info = info;
	}
	
	public String getInformation(){
		return info;
	}
	
	public void setMenu(String request){
		menu = request;
		menuObject = null;
		menuActive = !menuActive;
	}
	
	public String getMenu(){
		return menu;
	}
	
	public boolean isMenuActive(){
		return menuActive;
	}
	
	public void setMenuObject(Entity object){
		menuObject = object;
	}
	
	public Entity getMenuObject(){
		return menuObject;
	}
	
	public int getViewDistance() {
		return viewDistance;
	}

	public int getWallet() {
		return wallet;
	}

	public void setWallet(int wallet) {
		this.wallet = wallet;
	}
	
	public boolean isNewMap(){
		return newMap;
	}
	
	public void setNewMap(){
		newMap = !newMap;
	}
	
	public boolean isDead(){
		if(stats.getHitpoints() <= 0)
			return true;
		return false;
	}

	public boolean isHostile() {
		return hostile;
	}

	public void setHostility(boolean hostile) {
		this.hostile = hostile;
	}
	

	@Override
	public boolean keyUp(int keycode) {
		switch(keycode){
		case Keys.TAB:
			Global.camera.zoom -= .4;
			break;
		}
		return false;
	}

	@Override
	public boolean keyTyped(char character) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchDown(int screenX, int screenY, int pointer, int button) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchDragged(int screenX, int screenY, int pointer) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean mouseMoved(int x, int y) {
		
		return true;
	}
	
	
	
	private ArrayList<Node> open = new ArrayList<Node>();
	private ArrayList<Node> closed = new ArrayList<Node>(); // 0 up. 1 down. 2 left. 3 right.
	float tempX, tempY;
	Node smallest;
	boolean flag = false;
	
	public void findPath(Node target, Node parent){
		if(!closed.isEmpty() && closed.get(closed.size()-1).x == target.x && closed.get(closed.size()-1).y == target.y){
			Global.mapShapes.begin(ShapeType.Line);
			Global.mapShapes.setColor(Color.RED);
			while(parent != null){
				parent = parent.parent;
				Global.mapShapes.line(smallest.x + 14, smallest.y + 18, smallest.parent.x + 14, smallest.parent.y + 18);
			}
			Global.mapShapes.end();
			return;
		}
		
		// Gets the first square and all of the options around it that arn't blocked or already in open
		for(float i=parent.x-32; i<=parent.x+32; i+=32)
			for(float j=parent.y-32; j<=parent.y+32; j+=32)
				if(!(map.getTile(i, j).isBlocked() || (i == parent.x && j == parent.y))){
					flag = false;
					for(int q=0; q<closed.size(); q++)
						if(closed.get(q).x == i && closed.get(q).y == j)
							flag = true;
					if(!flag){
						flag = false;
						int q=0;
						for(; q<open.size(); q++)
							if(open.get(q).x == i && open.get(q).y == j){
								flag = true;
								if(open.get(q).x != parent.x && open.get(q).y != parent.y)
									tempX = 14;
								else
									tempX = 10;
								break;
							}
						if(flag){
							if(open.get(q).G > tempX)
								open.get(q).parent = parent;
						}
						else
							open.add(new Node(i, j, parent));
					}
				}
		closed.add(parent);
		
		// Calculates the H, G and F values
		for(int i=0; i<open.size(); i++){
			
			// Calculates the H values
			tempX = open.get(i).x;
			tempY = open.get(i).y;
			open.get(i).H = 0;
			while(tempX != target.x || tempY != target.y){
				if(target.x == tempX){
					if(target.y > tempY){
						tempY += 32;
					}
					else{
						tempY -= 32;
					}
				}
				else if(target.x > tempX){
					tempX += 32;
				}
				else{
					tempX -= 32;
				}
				open.get(i).H++;
			}
			open.get(i).H *= 10;

			// Calculates the G values
			if(open.get(i).x != parent.x && open.get(i).y != parent.y)
				open.get(i).G = 14;
			else
				open.get(i).G = 10;
			
			// Calculates the F values
			open.get(i).F = open.get(i).G + open.get(i).H;
			
			font.draw(map.getSpriteBatch(), "X", target.x + 10, target.y + 22);
			font.draw(map.getSpriteBatch(), Integer.toString(open.get(i).H), open.get(i).x + 10, open.get(i).y + 22);
			map.getSpriteBatch().end();
			/*Global.mapShapes.begin(ShapeType.Line);
			Global.mapShapes.setColor(Color.RED);
			Global.mapShapes.line(open.get(i).x + 14, open.get(i).y + 18, open.get(i).parent.x + 14, open.get(i).parent.y + 18);
			Global.mapShapes.end();*/
			map.getSpriteBatch().begin();
		}
		
		// Find the smallest F and close it
		smallest = open.get(0);
		for(int i=0; i<open.size(); i++)
			if(smallest.F > open.get(i).F)
				smallest = open.get(i);
		System.out.println(smallest.F);
		open.remove(smallest);

		findPath(target, smallest);
	}
}


class Node{
	float x, y;
	int F, G, H;
	String ID;
	Node parent;
	
	public Node(float x, float y){
		this.x = x;
		this.y = y;
		F = H = G = 0;
		parent = null;
	}
	
	public Node(float x, float y, Node parent){
		this.x = x;
		this.y = y;
		this.parent = parent;
		F = H = G = 0;
	}
}